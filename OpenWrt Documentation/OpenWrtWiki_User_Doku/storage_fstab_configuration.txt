====== Fstab 配置 ======

（本文译自本站英文版）

Fstab, 或者叫 **f**ile **s**ystems **tab**le, 是一个集中的配置，定义了必要时（例如启动设备时，或者在物理上连接它时），文件系统（通过在块设备上）应该如何被挂载。这样，你不需要在你想要访问它们时，手动挂载设备。挂载配置不仅包括静态文件系统，也包括 swap 分区。\\ 
Fstab UCI 子系统是所有选项被定义的地方，包括需要被挂载的全部设备和文件系统，文件位于： **///etc/config/fstab//**.\\
默认情况下，这个子系统和它的配置文件都不存在，因为对大多数 LEDE 用例（网络设备）来说，不需要它。\\
所以如果你需要配置这个，你首先需要创建它。

因为 LEDE 中处理挂载的工具是 **block**, 所以当前的选项都可以在它的 [[https://git.lede-project.org/?p=project/fstools.git;a=blob;f=block.c;hb=HEAD|source code]] 中找到。


==== 创建 fstab ====
你需要使用 //block// 工具。安装软件包 //block-mount//:
<code>root@lede:~# opkg update && opkg install block-mount
</code>
调用 //block detect// 来得到一个 fstab UCI 子系统配置文件的范例。
<code>root@lede:~# block detect > /etc/config/fstab
</code>

现在，有 UCI 子系统了，你可以使用 UCI 命令行来改变它，或者直接编辑文件本身。

把 ///// 设置到其他设备上是可行的，但是过程可能有点复杂，请查看 [[https://wiki.openwrt.org/doc/howto/extroot|HOWTO extroot]] 获取更多内容。\\ 
也可以查看这个教程 [[https://wiki.openwrt.org/doc/techref/block_mount|OpenWrt techref]] 来获取更多挂载过程的技术细节和使用的脚本。

==== 在启动时启用 fstab ====

要启动这个新的 UCI 子系统的功能以使挂载点在启动时被正确挂载，输入：
<code>root@lede:~# service fstab enable
</code>

===== 配置 =====

配置文件包括一个 //global// 部分，定义了默认值，//mount// 部分定义了文件系统的挂载，以及 //swap// 部分定义了将被激活的分区。
无论何时你改变了 fstab 配置，运行下面的命令以新的方式挂载所有内容：
<code>root@lede:~# block umount && block mount
</code>

==== Global 部分 ====

^名称          ^类型   ^必须^默认值^描述                                                 ^
|//anon_swap// |boolean|no      |0      |挂载没有自身配置的 swap 设备                               |
|//anon_mount//|boolean|no      |0      |挂载没有自身配置的块设备                                    |
|//auto_swap// |boolean|no      |1      |当出现时自动挂载 swap 设备                                 |
|//auto_mount//|boolean|no      |1      |当出现时自动挂载块设备                                     |
|//delay_root//|integer|no      |0      |在启动时，在尝试挂载 root 设备前等待 X 秒                    |
|//check_fs//  |boolean|no      |0      |在挂载前，在设备上运行 e2fsck                              |

==== Swap 部分 ====

^名称      ^类型  ^必须^默认值^描述                                                ^
|//device//|string|no      |-      |swap 分区的设备节点 (e.g. sda1)               |
|//uuid//  |string|no      |-      |swap 分区的 UUID                                  |
|//label// |string|no      |-      |swap 分区的标签 (例如 mkswap -L label /dev/sdb2)|

==== Mount 部分 ====

^名称      ^类型 ^必须^默认值^描述                                                                                        ^
|//device//|string|no      |-      |数据分区的设备节点 (e.g. sda1)                                                       |
|//uuid//  |string|no      |-      |数据分区的 UUID                                                                          |
|//target//|string|no      |-      |数据分区的挂载点。一些值有特殊的含义，参考下面的 Extroot 部分。|

===== SWAP 分区的正确大小 =====

如果你询问别人，或者在网上搜索，你会找到一个经验规律： //双倍内存大小// 用于内存小于等于 512MiB 的机器，//和内存大小相同//用于内存更多的机器。这个非常粗暴的估算确实也适用于你的嵌入式设备。\\ 
请注意，相对于真实的内存，swap 的 **访问时机** 非常深， 所以拥有 swap 在特定情况下，可能不会有明显的帮助。\\ 
一个 CUPS 假脱机服务器只有当 SWAP 可用时才能很好的工作，然而一些应用程序较之于把数据放在真实的内存中时，放在 SWAP 分区使它们表现非常差劲。\\ 
哪些数据存储在内存中，哪些存储在 SWAP 由系统决定。不同于其他操作系统，Linux 大量使用内存，所以你的系统可以运行流畅而且更有效率。如果应用程序需要使用内存时，系统再释放一些空间，使内存变得可用。